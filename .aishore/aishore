#!/bin/bash
# aishore - AI Sprint Runner CLI
# A self-contained sprint orchestration tool for Claude Code
#
# Usage: .aishore/aishore <command> [options]
#
# Commands:
#   run [count|ID]  Run sprints (default: 1) or specific item by ID
#   groom           Groom bugs/tech debt (Tech Lead)
#   groom --backlog Groom features (Product Owner)
#   review          Architecture review
#   metrics         Show sprint metrics
#   init            Initialize aishore in current project
#   help            Show this help

set -euo pipefail

AISHORE_VERSION="0.1.2"

# ============================================================================
# PATHS
# ============================================================================

AISHORE_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$AISHORE_ROOT")"

# Tool paths (in .aishore/ - can be updated)
CONFIG_FILE="$AISHORE_ROOT/config.yaml"
AGENTS_DIR="$AISHORE_ROOT/agents"
DATA_DIR="$AISHORE_ROOT/data"
STATUS_DIR="$DATA_DIR/status"
LOGS_DIR="$DATA_DIR/logs"

# User content paths (at project level - never touched by update)
BACKLOG_DIR="$PROJECT_ROOT/backlog"
ARCHIVE_DIR="$BACKLOG_DIR/archive"

# ============================================================================
# DEFAULTS (can be overridden by config.yaml or env vars)
# ============================================================================

MODEL_PRIMARY="${AISHORE_MODEL_PRIMARY:-claude-opus-4-5-20251101}"
MODEL_FAST="${AISHORE_MODEL_FAST:-claude-sonnet-4-20250514}"
AGENT_TIMEOUT="${AISHORE_AGENT_TIMEOUT:-3600}"
VALIDATE_CMD="${AISHORE_VALIDATE_CMD:-}"
VALIDATE_TIMEOUT="${AISHORE_VALIDATE_TIMEOUT:-120}"

# ============================================================================
# COLORS & LOGGING (inlined from common.sh)
# ============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

log_header()  { echo -e "\n${BLUE}════════════════════════════════════════${NC}\n${BLUE}  $1${NC}\n${BLUE}════════════════════════════════════════${NC}"; }
log_subheader() { echo -e "\n${CYAN}─── $1 ───${NC}"; }
log_success() { echo -e "${GREEN}✓ $1${NC}"; }
log_warning() { echo -e "${YELLOW}⚠ $1${NC}"; }
log_error()   { echo -e "${RED}✗ $1${NC}"; }
log_info()    { echo -e "${CYAN}$1${NC}"; }
log_agent()   { echo -e "${MAGENTA}[$1]${NC} $2"; }

# ============================================================================
# UTILITIES (inlined from common.sh)
# ============================================================================

iso_timestamp() { date -Iseconds; }

append_log() {
    local file="$1" msg="$2"
    mkdir -p "$(dirname "$file")" 2>/dev/null || true
    echo "$msg" >> "$file"
}

check_signal() {
    local signal_name="$1"
    local output_file="$2"
    [[ ! -s "$output_file" ]] && return 1
    grep -qE "<<[[:space:]]*SIGNAL[[:space:]]*:[[:space:]]*${signal_name}[[:space:]]*>>" "$output_file" 2>/dev/null
}

# ============================================================================
# AUTO-DETECT CLAUDE.MD
# ============================================================================

find_claude_md() {
    local dir="$PROJECT_ROOT"
    # Check common locations
    for path in "$dir/CLAUDE.md" "$dir/claude.md" "$dir/docs/CLAUDE.md"; do
        [[ -f "$path" ]] && { echo "$path"; return 0; }
    done
    return 1
}

# ============================================================================
# CONFIGURATION (optional config.yaml, sensible defaults)
# ============================================================================

load_config() {
    # Only load if config exists
    [[ ! -f "$CONFIG_FILE" ]] && return 0

    if command -v yq &> /dev/null; then
        VALIDATE_CMD=$(yq -r '.validation.command // ""' "$CONFIG_FILE")
        VALIDATE_TIMEOUT=$(yq -r '.validation.timeout // 120' "$CONFIG_FILE")
        local cfg_primary=$(yq -r '.models.primary // ""' "$CONFIG_FILE")
        local cfg_fast=$(yq -r '.models.fast // ""' "$CONFIG_FILE")
        local cfg_timeout=$(yq -r '.agent.timeout // ""' "$CONFIG_FILE")
        [[ -n "$cfg_primary" ]] && MODEL_PRIMARY="$cfg_primary"
        [[ -n "$cfg_fast" ]] && MODEL_FAST="$cfg_fast"
        [[ -n "$cfg_timeout" ]] && AGENT_TIMEOUT="$cfg_timeout"
    else
        # Simple grep fallback for validation command only
        VALIDATE_CMD=$(grep -E '^\s*command:' "$CONFIG_FILE" 2>/dev/null | head -1 | sed 's/.*command:\s*//' | tr -d '"' || echo "")
    fi
}

# ============================================================================
# ITEM SELECTION
# ============================================================================

pick_item() {
    local specific_id="${1:-}"
    local item_json
    local source_file="$STATUS_DIR/.item_source"

    if [[ -n "$specific_id" ]]; then
        # Pick specific item by ID
        for backlog in "backlog.json" "bugs.json"; do
            item_json=$(jq -r --arg id "$specific_id" '
                .items[] | select(.id == $id) |
                {id, title, description, steps, acceptanceCriteria, priority}
            ' "$BACKLOG_DIR/$backlog" 2>/dev/null)
            if [[ -n "$item_json" && "$item_json" != "null" ]]; then
                echo "$backlog" > "$source_file"
                echo "$item_json"
                return 0
            fi
        done
        log_error "Item not found: $specific_id"
        return 1
    fi

    # Auto-pick: highest priority ready item
    for backlog in "backlog.json" "bugs.json"; do
        item_json=$(jq -r '
            [.items[] |
            select(.readyForSprint == true and (.passes == false or .passes == null) and (.status == "todo" or .status == null)) |
            . + {_priorityOrder: (if .priority == "must" then 0 elif .priority == "should" then 1 elif .priority == "could" then 2 else 3 end)}] |
            sort_by(._priorityOrder) |
            first |
            if . then {id, title, description, steps, acceptanceCriteria, priority} else empty end
        ' "$BACKLOG_DIR/$backlog" 2>/dev/null)

        if [[ -n "$item_json" && "$item_json" != "null" ]]; then
            echo "$backlog" > "$source_file"
            echo "$item_json"
            return 0
        fi
    done

    return 1
}

get_item_source() {
    local source_file="$STATUS_DIR/.item_source"
    [[ -f "$source_file" ]] && cat "$source_file" || echo ""
}

# ============================================================================
# SPRINT STATE
# ============================================================================

create_sprint() {
    local item_json="$1"
    local source="$2"
    local item_id=$(echo "$item_json" | jq -r '.id')
    local title=$(echo "$item_json" | jq -r '.title // .description')

    cat > "$BACKLOG_DIR/sprint.json" <<EOF
{
  "sprintId": "sprint-$(date +%s)",
  "startedAt": "$(date -Iseconds)",
  "status": "in_progress",
  "item": {
    "id": "$item_id",
    "title": $(echo "$title" | jq -R .),
    "sourceBacklog": "$source",
    "steps": $(echo "$item_json" | jq '.steps // []'),
    "acceptanceCriteria": $(echo "$item_json" | jq '.acceptanceCriteria // []'),
    "startedAt": "$(date -Iseconds)"
  }
}
EOF

    ITEM_ID="$item_id"
    log_info "Sprint created: $item_id - $title"
}

mark_complete() {
    local item_id="$1"
    local source="$2"
    local now=$(date -Iseconds)

    [[ -z "$source" ]] && { log_error "Cannot mark complete: source backlog is empty"; return 1; }

    # Update source backlog
    local tmp=$(mktemp)
    if jq --arg id "$item_id" --arg ts "$now" '
        (.items[] | select(.id == $id)) |= . + {passes: true, status: "done", readyForSprint: false, completedAt: $ts}
    ' "$BACKLOG_DIR/$source" > "$tmp" 2>/dev/null; then
        mv "$tmp" "$BACKLOG_DIR/$source"
    else
        rm -f "$tmp"
        log_error "Failed to update $source"
        return 1
    fi

    # Update sprint.json
    tmp=$(mktemp)
    jq --arg ts "$now" '.status = "completed" | .completedAt = $ts | .item.status = "passed" | .item.completedAt = $ts' \
        "$BACKLOG_DIR/sprint.json" > "$tmp" && mv "$tmp" "$BACKLOG_DIR/sprint.json"

    # Append to archive
    local sprint_id=$(jq -r '.sprintId' "$BACKLOG_DIR/sprint.json")
    echo "{\"date\":\"$(date +%Y-%m-%d)\",\"sprintId\":\"$sprint_id\",\"itemId\":\"$item_id\",\"status\":\"complete\"}" \
        >> "$ARCHIVE_DIR/sprints.jsonl"
}

reset_sprint() {
    cat > "$BACKLOG_DIR/sprint.json" <<'EOF'
{"sprintId": null, "status": "idle", "item": null}
EOF
}

# ============================================================================
# AGENT EXECUTION
# ============================================================================

run_agent() {
    local agent_name="$1"
    local mode="$2"
    local model="${3:-$MODEL_PRIMARY}"

    local prompt_file="$AGENTS_DIR/${agent_name}.md"
    [[ ! -f "$prompt_file" ]] && { log_error "Agent not found: $agent_name"; return 1; }

    rm -f "$STATUS_DIR/result.json"

    # Build context: sprint.json + auto-detected CLAUDE.md
    local context_files="@$BACKLOG_DIR/sprint.json"
    local claude_md=$(find_claude_md)
    [[ -n "$claude_md" ]] && context_files="$context_files @$claude_md"

    # Build prompt with completion contract
    local prompt=$(cat "$prompt_file")
    prompt="$prompt

## Mode
$mode

## Completion Contract
When you are finished, you MUST write to \`.aishore/data/status/result.json\`:

On success:
\`\`\`json
{\"status\": \"pass\", \"summary\": \"brief description of what was done\"}
\`\`\`

On failure:
\`\`\`json
{\"status\": \"fail\", \"reason\": \"what went wrong\"}
\`\`\`

This file is how the orchestrator knows you finished. Write it as your final action."

    log_agent "$agent_name" "Starting (model: $model, timeout: ${AGENT_TIMEOUT}s)"
    local start_time=$(date +%s)

    setsid env -u CLAUDECODE -u CLAUDE_CODE_ENTRYPOINT \
        claude --model "$model" \
        --permission-mode acceptEdits \
        --allowedTools "Bash(git:*),Edit,Write,Read,Glob,Grep" \
        --output-format text \
        -p "$context_files
$prompt" &

    local agent_pid=$!
    local elapsed=0

    while [[ $elapsed -lt $AGENT_TIMEOUT ]]; do
        if ! kill -0 "$agent_pid" 2>/dev/null; then
            break
        fi
        if [[ -f "$STATUS_DIR/result.json" ]]; then
            sleep 2
            break
        fi
        sleep 5
        elapsed=$((elapsed + 5))
    done

    if kill -0 "$agent_pid" 2>/dev/null; then
        log_warning "Agent timed out after ${AGENT_TIMEOUT}s, killing..."
        kill -TERM -"$agent_pid" 2>/dev/null || kill -TERM "$agent_pid" 2>/dev/null
        sleep 2
        kill -KILL -"$agent_pid" 2>/dev/null || true
    fi

    wait "$agent_pid" 2>/dev/null || true

    local duration=$(($(date +%s) - start_time))
    log_agent "$agent_name" "Completed in ${duration}s"

    append_log "$LOGS_DIR/agent-runs.log" \
        "$(iso_timestamp)|$agent_name|$mode|${duration}s|$model"
}

check_result() {
    if [[ ! -f "$STATUS_DIR/result.json" ]]; then
        log_error "No result file - agent may have crashed"
        return 1
    fi

    local status=$(jq -r '.status // "unknown"' "$STATUS_DIR/result.json" 2>/dev/null)

    if [[ "$status" == "pass" ]]; then
        local summary=$(jq -r '.summary // "completed"' "$STATUS_DIR/result.json")
        log_success "$summary"
        return 0
    else
        local reason=$(jq -r '.reason // "unknown error"' "$STATUS_DIR/result.json")
        log_error "$reason"
        return 1
    fi
}

# ============================================================================
# COMMANDS
# ============================================================================

cmd_run() {
    local count=1
    local auto_commit=false
    local specific_id=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-commit) auto_commit=true; shift ;;
            *)
                if [[ "$1" =~ ^[0-9]+$ ]]; then
                    count="$1"
                else
                    # Assume it's an item ID (e.g., TEST-006, FEAT-001)
                    specific_id="$1"
                    count=1
                fi
                shift ;;
        esac
    done

    load_config
    cd "$PROJECT_ROOT"

    log_header "aishore - Sprint Runner"
    echo "Project: $PROJECT_ROOT"
    if [[ -n "$specific_id" ]]; then
        echo "Item: $specific_id"
    else
        echo "Sprints: $count"
    fi
    [[ "$auto_commit" == "true" ]] && echo "Auto-commit: enabled"
    echo ""

    local passed=0 failed=0

    for ((i=1; i<=count; i++)); do
        [[ $count -gt 1 ]] && log_subheader "Sprint $i/$count"

        local item_json
        if ! item_json=$(pick_item "$specific_id"); then
            if [[ -n "$specific_id" ]]; then
                log_error "Item not found: $specific_id"
            else
                log_warning "No ready items in backlog"
            fi
            break
        fi

        local item_source=$(get_item_source)
        [[ -z "$item_source" ]] && { log_error "Failed to determine item source"; break; }

        create_sprint "$item_json" "$item_source"

        # Run developer
        run_agent "developer" "implement" "$MODEL_PRIMARY"
        if ! check_result; then
            log_error "Implementation failed"
            ((failed++)) || true
            git checkout -- . 2>/dev/null || true
            git clean -fd 2>/dev/null || true
            reset_sprint
            continue
        fi

        # Run validator
        run_agent "validator" "validate" "$MODEL_FAST"
        if ! check_result; then
            log_error "Validation failed"
            ((failed++)) || true
            git checkout -- . 2>/dev/null || true
            git clean -fd 2>/dev/null || true
            reset_sprint
            continue
        fi

        # Success
        if mark_complete "$ITEM_ID" "$item_source"; then
            log_success "Sprint complete: $ITEM_ID"
            ((passed++)) || true
        else
            log_error "Failed to mark $ITEM_ID complete"
            ((failed++)) || true
            continue
        fi

        # Handle commits
        if [[ "$auto_commit" == "true" ]]; then
            git add -A && git diff --cached --quiet || \
                git commit -m "feat($ITEM_ID): implement sprint item

Co-Authored-By: Claude <noreply@anthropic.com>"
        elif [[ $count -eq 1 ]]; then
            echo ""
            git status --short
            read -p "Commit? [y/N] " c
            if [[ $c == [yY] ]]; then
                git add -A && git commit -m "feat($ITEM_ID): implement sprint item

Co-Authored-By: Claude <noreply@anthropic.com>"
            fi
        fi
    done

    log_header "Results: $passed passed, $failed failed"
    [[ $failed -gt 0 || $passed -eq 0 ]] && exit 1 || exit 0
}

cmd_groom() {
    local mode="bugs"
    [[ "${1:-}" == "--backlog" ]] && mode="backlog"

    load_config
    cd "$PROJECT_ROOT"

    local agent context
    if [[ "$mode" == "backlog" ]]; then
        log_header "Product Owner: Backlog Grooming"
        agent="product-owner"
        context="@$BACKLOG_DIR/backlog.json @$BACKLOG_DIR/bugs.json"
    else
        log_header "Tech Lead: Bugs/Tech Debt Grooming"
        agent="tech-lead"
        context="@$BACKLOG_DIR/backlog.json @$BACKLOG_DIR/bugs.json"
    fi

    # Add CLAUDE.md if found
    local claude_md=$(find_claude_md)
    [[ -n "$claude_md" ]] && context="$context @$claude_md"

    local ready_backlog=$(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$BACKLOG_DIR/backlog.json" 2>/dev/null || echo 0)
    local ready_bugs=$(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$BACKLOG_DIR/bugs.json" 2>/dev/null || echo 0)
    log_info "Current ready buffer: $((ready_backlog + ready_bugs)) items ($ready_backlog features, $ready_bugs bugs)"
    echo ""

    rm -f "$STATUS_DIR/result.json"

    local prompt=$(cat "$AGENTS_DIR/${agent}.md")
    prompt="$prompt

## Mode
groom

## Completion Contract
When finished, write to \`.aishore/data/status/result.json\`:
\`\`\`json
{\"status\": \"pass\", \"summary\": \"Groomed X items, Y now ready for sprint\"}
\`\`\`"

    log_info "Running $agent agent..."

    setsid env -u CLAUDECODE -u CLAUDE_CODE_ENTRYPOINT \
        claude --model "$MODEL_PRIMARY" \
        --permission-mode acceptEdits \
        --allowedTools "Bash(git:*),Edit,Write,Read,Glob,Grep" \
        --output-format text \
        -p "$context
$prompt" &

    local agent_pid=$!
    local elapsed=0

    while [[ $elapsed -lt $AGENT_TIMEOUT ]]; do
        ! kill -0 "$agent_pid" 2>/dev/null && break
        [[ -f "$STATUS_DIR/result.json" ]] && { sleep 2; break; }
        sleep 5
        elapsed=$((elapsed + 5))
    done

    kill -0 "$agent_pid" 2>/dev/null && {
        kill -TERM -"$agent_pid" 2>/dev/null || kill -TERM "$agent_pid" 2>/dev/null
        sleep 2
        kill -KILL -"$agent_pid" 2>/dev/null || true
    }

    wait "$agent_pid" 2>/dev/null || true
    check_result
}

cmd_review() {
    local update_docs=false
    local since=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --update-docs) update_docs=true; shift ;;
            --since) since="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    load_config
    cd "$PROJECT_ROOT"

    log_header "Architecture Review"
    echo "Mode: $([[ "$update_docs" == "true" ]] && echo "Update docs" || echo "Read-only")"
    echo ""

    local context="@$BACKLOG_DIR/backlog.json @$BACKLOG_DIR/bugs.json"
    [[ -f "$ARCHIVE_DIR/sprints.jsonl" ]] && context="$context @$ARCHIVE_DIR/sprints.jsonl"
    local claude_md=$(find_claude_md)
    [[ -n "$claude_md" ]] && context="$context @$claude_md"

    local allowed_tools="Bash(git:*),Read,Glob,Grep"
    [[ "$update_docs" == "true" ]] && allowed_tools="Bash(git:*),Edit,Write,Read,Glob,Grep"

    local prompt=$(cat "$AGENTS_DIR/architect.md")
    prompt="$prompt

## Additional Context
$([[ -n "$since" ]] && echo "Review changes since commit: $since")
$([[ "$update_docs" == "true" ]] && echo "You may update documentation and add backlog items." || echo "Read-only review. Do not modify files.")

CRITICAL: End with: <<SIGNAL:ARCHITECT_REVIEW_COMPLETE>>"

    local output_file=$(mktemp)

    log_info "Running architect agent..."

    setsid env -u CLAUDECODE -u CLAUDE_CODE_ENTRYPOINT \
        claude --model "$MODEL_PRIMARY" \
        --permission-mode acceptEdits \
        --allowedTools "$allowed_tools" \
        --print \
        -p "$context
$prompt" > "$output_file" 2>&1 &

    local agent_pid=$!
    local elapsed=0

    while kill -0 "$agent_pid" 2>/dev/null; do
        sleep 5
        elapsed=$((elapsed + 5))
        [[ $elapsed -ge $AGENT_TIMEOUT ]] && {
            log_warning "Agent timed out"
            kill -TERM -"$agent_pid" 2>/dev/null || kill -TERM "$agent_pid" 2>/dev/null
            break
        }
    done

    wait "$agent_pid" 2>/dev/null || true

    if check_signal "ARCHITECT_REVIEW_COMPLETE" "$output_file"; then
        log_success "Architecture review complete"
    else
        log_warning "Review may be incomplete"
    fi

    rm -f "$output_file"
}

cmd_metrics() {
    local json_output=false
    [[ "${1:-}" == "--json" ]] && json_output=true

    load_config

    local sprints_file="$ARCHIVE_DIR/sprints.jsonl"
    local backlog_file="$BACKLOG_DIR/backlog.json"
    local bugs_file="$BACKLOG_DIR/bugs.json"

    if [[ "$json_output" == "true" ]]; then
        local completed=$([[ -f "$sprints_file" ]] && wc -l < "$sprints_file" | tr -d ' ' || echo 0)
        local backlog_total=$(jq '.items | length' "$backlog_file" 2>/dev/null || echo 0)
        local bugs_total=$(jq '.items | length' "$bugs_file" 2>/dev/null || echo 0)
        local ready_backlog=$(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$backlog_file" 2>/dev/null || echo 0)
        local ready_bugs=$(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$bugs_file" 2>/dev/null || echo 0)

        cat <<EOF
{
  "timestamp": "$(date -Iseconds)",
  "sprints": {"completed": $completed},
  "backlog": {"total": $backlog_total, "ready": $ready_backlog},
  "bugs": {"total": $bugs_total, "ready": $ready_bugs}
}
EOF
    else
        log_header "aishore Metrics"
        echo ""
        echo "Completed Sprints: $([[ -f "$sprints_file" ]] && wc -l < "$sprints_file" | tr -d ' ' || echo 0)"
        echo ""
        echo "Backlog:"
        echo "  Total items: $(jq '.items | length' "$backlog_file" 2>/dev/null || echo 0)"
        echo "  Ready for sprint: $(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$backlog_file" 2>/dev/null || echo 0)"
        echo ""
        echo "Bugs/Tech Debt:"
        echo "  Total items: $(jq '.items | length' "$bugs_file" 2>/dev/null || echo 0)"
        echo "  Ready for sprint: $(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$bugs_file" 2>/dev/null || echo 0)"
    fi
}

cmd_init() {
    log_header "Initializing aishore"

    if [[ -f "$BACKLOG_DIR/backlog.json" ]]; then
        log_warning "aishore already initialized (backlog.json exists)"
        read -p "Reinitialize? [y/N] " c
        [[ $c != [yY] ]] && exit 0
    fi

    # Create directories
    mkdir -p "$STATUS_DIR" "$LOGS_DIR" "$ARCHIVE_DIR" "$BACKLOG_DIR/archive" "$AGENTS_DIR"

    # Create minimal config (optional, for overrides only)
    [[ ! -f "$CONFIG_FILE" ]] && cat > "$CONFIG_FILE" << 'EOF'
# aishore configuration (optional - sensible defaults are used)
# Uncomment and modify only what you need to override

# validation:
#   command: "npm run type-check && npm run lint && npm test"
#   timeout: 120

# models:
#   primary: "claude-opus-4-5-20251101"
#   fast: "claude-sonnet-4-20250514"

# agent:
#   timeout: 3600
EOF

    # Create backlog if missing
    [[ ! -f "$BACKLOG_DIR/backlog.json" ]] && cat > "$BACKLOG_DIR/backlog.json" << 'EOF'
{
  "description": "Feature backlog",
  "items": []
}
EOF

    # Create bugs.json if missing
    [[ ! -f "$BACKLOG_DIR/bugs.json" ]] && cat > "$BACKLOG_DIR/bugs.json" << 'EOF'
{
  "description": "Bugs and tech debt",
  "items": []
}
EOF

    # Create sprint.json if missing
    [[ ! -f "$BACKLOG_DIR/sprint.json" ]] && echo '{"sprintId": null, "status": "idle", "item": null}' > "$BACKLOG_DIR/sprint.json"

    # Create archive file
    touch "$ARCHIVE_DIR/sprints.jsonl"

    # Update .gitignore
    local gitignore="$PROJECT_ROOT/.gitignore"
    if [[ -f "$gitignore" ]]; then
        if ! grep -q ".aishore/data/logs/" "$gitignore" 2>/dev/null; then
            echo -e "\n# aishore runtime files\n.aishore/data/logs/\n.aishore/data/status/result.json" >> "$gitignore"
        fi
    fi

    log_success "aishore initialized!"
    echo ""
    echo "Next steps:"
    echo "  1. Add features to backlog/backlog.json"
    echo "  2. Run: .aishore/aishore groom"
    echo "  3. Run: .aishore/aishore run"
    echo ""
    echo "Optional: Edit .aishore/config.yaml to override defaults"

    local claude_md=$(find_claude_md)
    if [[ -n "$claude_md" ]]; then
        log_success "Found $claude_md - will be used automatically"
    else
        log_info "Tip: Create CLAUDE.md in project root for project context"
    fi
}

cmd_version() {
    echo "aishore version $AISHORE_VERSION"
}

cmd_update() {
    local repo_url="https://raw.githubusercontent.com/simonplant/aishore/main"
    local dry_run=false
    [[ "${1:-}" == "--dry-run" ]] && dry_run=true

    log_header "aishore Update"
    echo "Current version: $AISHORE_VERSION"
    echo ""

    # Check for curl or wget
    local fetch_cmd=""
    if command -v curl &> /dev/null; then
        fetch_cmd="curl -fsSL"
    elif command -v wget &> /dev/null; then
        fetch_cmd="wget -qO-"
    else
        log_error "curl or wget required for update"
        exit 1
    fi

    # Fetch remote version
    local remote_script
    remote_script=$($fetch_cmd "$repo_url/.aishore/aishore" 2>/dev/null) || {
        log_error "Failed to fetch from $repo_url"
        exit 1
    }

    local remote_version
    remote_version=$(echo "$remote_script" | grep -E '^AISHORE_VERSION=' | head -1 | cut -d'"' -f2)

    if [[ -z "$remote_version" ]]; then
        log_error "Could not determine remote version"
        exit 1
    fi

    echo "Remote version: $remote_version"
    echo ""

    if [[ "$AISHORE_VERSION" == "$remote_version" ]]; then
        log_success "Already up to date"
        return 0
    fi

    if [[ "$dry_run" == "true" ]]; then
        log_info "Dry run - would update to $remote_version"
        return 0
    fi

    log_info "Updating aishore script..."
    echo "$remote_script" > "$AISHORE_ROOT/aishore"
    chmod +x "$AISHORE_ROOT/aishore"

    # Update agent prompts
    for agent in developer validator tech-lead product-owner architect; do
        log_info "Updating agents/$agent.md..."
        $fetch_cmd "$repo_url/.aishore/agents/$agent.md" > "$AGENTS_DIR/$agent.md" 2>/dev/null || \
            log_warning "Could not update $agent.md"
    done

    log_success "Updated to $remote_version"
    echo ""
    echo "Note: config.yaml and backlog/ were not modified (your content)"
}

cmd_help() {
    cat << EOF
aishore - AI Sprint Runner (v$AISHORE_VERSION)

Usage: .aishore/aishore <command> [options]

Commands:
  run [count]       Run N sprints (default: 1)
  run <ID>          Run specific item by ID (e.g., TEST-006)
    --auto-commit   Automatically commit after each sprint

  groom             Groom bugs/tech debt (Tech Lead mode)
    --backlog       Groom features instead (Product Owner mode)

  review            Architecture review (read-only)
    --update-docs   Allow updates to docs
    --since <hash>  Review since specific commit

  metrics           Show sprint metrics
    --json          Output as JSON

  update            Update aishore from upstream
    --dry-run       Check for updates without applying

  init              Initialize aishore in current project
  version           Show version
  help              Show this help

Examples:
  .aishore/aishore run              # Run 1 sprint (auto-pick)
  .aishore/aishore run 5            # Run 5 sprints
  .aishore/aishore run TEST-006     # Run specific item
  .aishore/aishore run --auto-commit 3
  .aishore/aishore groom
  .aishore/aishore update --dry-run

Files:
  backlog/backlog.json    Your feature backlog (user content)
  backlog/bugs.json       Your bugs/tech debt (user content)
  backlog/sprint.json     Current sprint state
  .aishore/config.yaml    Optional configuration overrides
  .aishore/agents/        Agent prompts (updated by 'update')

Environment Variables:
  AISHORE_MODEL_PRIMARY     Primary model (default: claude-opus-4-5-20251101)
  AISHORE_MODEL_FAST        Fast model (default: claude-sonnet-4-20250514)
  AISHORE_AGENT_TIMEOUT     Agent timeout in seconds (default: 3600)
EOF
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    mkdir -p "$STATUS_DIR" "$LOGS_DIR" "$ARCHIVE_DIR" "$BACKLOG_DIR/archive"

    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        run)     cmd_run "$@" ;;
        groom)   cmd_groom "$@" ;;
        review)  cmd_review "$@" ;;
        metrics) cmd_metrics "$@" ;;
        update)  cmd_update "$@" ;;
        init)    cmd_init "$@" ;;
        version|-v|--version) cmd_version ;;
        help|-h|--help) cmd_help ;;
        *)
            log_error "Unknown command: $cmd"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
