#!/bin/bash
# aishore - AI Sprint Runner CLI
# A self-contained sprint orchestration tool for Claude Code
#
# Usage: .aishore/aishore <command> [options]
#
# Commands:
#   run [count]     Run sprints (default: 1)
#   groom           Groom bugs/tech debt (Tech Lead)
#   groom --backlog Groom features (Product Owner)
#   review          Architecture review
#   metrics         Show sprint metrics
#   init            Initialize aishore in current project
#   help            Show this help

set -euo pipefail

AISHORE_VERSION="1.0.0"

# ============================================================================
# PATHS (relative to .aishore/)
# ============================================================================

AISHORE_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$AISHORE_ROOT")"
CONFIG_FILE="$AISHORE_ROOT/config.yaml"
PLAN_DIR="$AISHORE_ROOT/plan"
DATA_DIR="$AISHORE_ROOT/data"
AGENTS_DIR="$AISHORE_ROOT/agents"
CONTEXT_DIR="$AISHORE_ROOT/context"
LIB_DIR="$AISHORE_ROOT/lib"

# Runtime directories
STATUS_DIR="$DATA_DIR/status"
LOGS_DIR="$DATA_DIR/logs"
ARCHIVE_DIR="$DATA_DIR/archive"

# Source library
source "$LIB_DIR/common.sh"

# ============================================================================
# CONFIGURATION LOADING
# ============================================================================

load_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_error "Config not found: $CONFIG_FILE"
        log_info "Run '.aishore/aishore init' to initialize"
        exit 1
    fi

    # Load config values (uses yq if available, falls back to grep/sed)
    if command -v yq &> /dev/null; then
        VALIDATE_CMD=$(yq -r '.validation.command // "echo No validation configured"' "$CONFIG_FILE")
        VALIDATE_TIMEOUT=$(yq -r '.validation.timeout // 120' "$CONFIG_FILE")
        MODEL_PRIMARY=$(yq -r '.models.primary // "claude-opus-4-5-20251101"' "$CONFIG_FILE")
        MODEL_FAST=$(yq -r '.models.fast // "claude-sonnet-4-20250514"' "$CONFIG_FILE")
        AGENT_TIMEOUT=$(yq -r '.agent.timeout // 600' "$CONFIG_FILE")
        CONTEXT_PROJECT=$(yq -r '.context.project // "context/project.md"' "$CONFIG_FILE")
        CONTEXT_PRODUCT=$(yq -r '.context.product // ""' "$CONFIG_FILE")
    else
        # Fallback: simple grep-based parsing (works for simple YAML)
        VALIDATE_CMD=$(grep -E '^\s*command:' "$CONFIG_FILE" | head -1 | sed 's/.*command:\s*//' | tr -d '"' || echo "echo No validation configured")
        VALIDATE_TIMEOUT=$(grep -E '^\s*timeout:' "$CONFIG_FILE" | head -1 | sed 's/.*timeout:\s*//' || echo "120")
        MODEL_PRIMARY=$(grep -E '^\s*primary:' "$CONFIG_FILE" | sed 's/.*primary:\s*//' | tr -d '"' || echo "claude-opus-4-5-20251101")
        MODEL_FAST=$(grep -E '^\s*fast:' "$CONFIG_FILE" | sed 's/.*fast:\s*//' | tr -d '"' || echo "claude-sonnet-4-20250514")
        AGENT_TIMEOUT=$(grep -E 'timeout:' "$CONFIG_FILE" | tail -1 | sed 's/.*timeout:\s*//' || echo "600")
        CONTEXT_PROJECT="context/project.md"
        CONTEXT_PRODUCT=""
    fi

    # Export for common.sh
    export AISHORE_VALIDATE_CMD="$VALIDATE_CMD"
    export AISHORE_TEST_TIMEOUT="$VALIDATE_TIMEOUT"
    export MODEL_OPUS="$MODEL_PRIMARY"
    export MODEL_SONNET="$MODEL_FAST"
    export AISHORE_AGENT_TIMEOUT="$AGENT_TIMEOUT"

    # Resolve context paths
    if [[ -n "$CONTEXT_PROJECT" && ! "$CONTEXT_PROJECT" =~ ^/ ]]; then
        CONTEXT_PROJECT="$AISHORE_ROOT/$CONTEXT_PROJECT"
    fi
    if [[ -n "$CONTEXT_PRODUCT" && ! "$CONTEXT_PRODUCT" =~ ^/ ]]; then
        CONTEXT_PRODUCT="$AISHORE_ROOT/$CONTEXT_PRODUCT"
    fi
}

# ============================================================================
# ITEM SELECTION
# ============================================================================

pick_item() {
    local item_json
    local source_file="$STATUS_DIR/.item_source"

    # Try backlog.json first
    item_json=$(jq -r '
        [.items[] |
        select(.readyForSprint == true and (.passes == false or .passes == null) and (.status == "todo" or .status == null)) |
        . + {_priorityOrder: (if .priority == "must" then 0 elif .priority == "should" then 1 elif .priority == "could" then 2 else 3 end)}] |
        sort_by(._priorityOrder) |
        first |
        if . then {id, title, description, steps, acceptanceCriteria, priority} else empty end
    ' "$PLAN_DIR/backlog.json" 2>/dev/null)

    if [[ -n "$item_json" && "$item_json" != "null" ]]; then
        echo "backlog.json" > "$source_file"
        echo "$item_json"
        return 0
    fi

    # Try bugs.json
    item_json=$(jq -r '
        [.items[] |
        select(.readyForSprint == true and (.passes == false or .passes == null) and (.status == "todo" or .status == null)) |
        . + {_priorityOrder: (if .priority == "must" then 0 elif .priority == "should" then 1 elif .priority == "could" then 2 else 3 end)}] |
        sort_by(._priorityOrder) |
        first |
        if . then {id, title, description, steps, acceptanceCriteria, priority} else empty end
    ' "$PLAN_DIR/bugs.json" 2>/dev/null)

    if [[ -n "$item_json" && "$item_json" != "null" ]]; then
        echo "bugs.json" > "$source_file"
        echo "$item_json"
        return 0
    fi

    return 1
}

get_item_source() {
    local source_file="$STATUS_DIR/.item_source"
    [[ -f "$source_file" ]] && cat "$source_file" || echo ""
}

# ============================================================================
# SPRINT STATE
# ============================================================================

create_sprint() {
    local item_json="$1"
    local source="$2"
    local item_id=$(echo "$item_json" | jq -r '.id')
    local title=$(echo "$item_json" | jq -r '.title // .description')
    local sprint_num=$(date +%s)

    cat > "$PLAN_DIR/sprint.json" <<EOF
{
  "sprintId": "sprint-$sprint_num",
  "startedAt": "$(date -Iseconds)",
  "status": "in_progress",
  "item": {
    "id": "$item_id",
    "title": $(echo "$title" | jq -R .),
    "sourceBacklog": "$source",
    "steps": $(echo "$item_json" | jq '.steps // []'),
    "acceptanceCriteria": $(echo "$item_json" | jq '.acceptanceCriteria // []'),
    "startedAt": "$(date -Iseconds)"
  }
}
EOF

    ITEM_ID="$item_id"
    log_info "Sprint created: $item_id - $title"
}

mark_complete() {
    local item_id="$1"
    local source="$2"
    local now=$(date -Iseconds)

    [[ -z "$source" ]] && { log_error "Cannot mark complete: source backlog is empty"; return 1; }

    # Update source backlog
    local tmp=$(mktemp)
    if jq --arg id "$item_id" --arg ts "$now" '
        (.items[] | select(.id == $id)) |= . + {passes: true, status: "done", readyForSprint: false, completedAt: $ts}
    ' "$PLAN_DIR/$source" > "$tmp" 2>/dev/null; then
        mv "$tmp" "$PLAN_DIR/$source"
    else
        rm -f "$tmp"
        log_error "Failed to update $source"
        return 1
    fi

    # Update sprint.json
    tmp=$(mktemp)
    jq --arg ts "$now" '.status = "completed" | .completedAt = $ts | .item.status = "passed" | .item.completedAt = $ts' \
        "$PLAN_DIR/sprint.json" > "$tmp" && mv "$tmp" "$PLAN_DIR/sprint.json"

    # Append to archive
    local sprint_id=$(jq -r '.sprintId' "$PLAN_DIR/sprint.json")
    echo "{\"date\":\"$(date +%Y-%m-%d)\",\"sprintId\":\"$sprint_id\",\"itemId\":\"$item_id\",\"status\":\"complete\"}" \
        >> "$ARCHIVE_DIR/sprints.jsonl"
}

reset_sprint() {
    cat > "$PLAN_DIR/sprint.json" <<'EOF'
{"sprintId": null, "status": "idle", "item": null}
EOF
}

# ============================================================================
# AGENT EXECUTION
# ============================================================================

run_agent() {
    local agent_name="$1"
    local mode="$2"

    local prompt_file="$AGENTS_DIR/${agent_name}.md"
    [[ ! -f "$prompt_file" ]] && { log_error "Agent not found: $agent_name"; return 1; }

    # Clear previous result
    rm -f "$STATUS_DIR/result.json"

    # Build context file list
    local context_files="@$PLAN_DIR/sprint.json"
    [[ -f "$CONTEXT_PROJECT" ]] && context_files="$context_files @$CONTEXT_PROJECT"

    # Build prompt
    local prompt=$(cat "$prompt_file")
    prompt="$prompt

## Mode
$mode

## Completion Contract
When you are finished, you MUST write to \`.aishore/data/status/result.json\`:

On success:
\`\`\`json
{\"status\": \"pass\", \"summary\": \"brief description of what was done\"}
\`\`\`

On failure:
\`\`\`json
{\"status\": \"fail\", \"reason\": \"what went wrong\"}
\`\`\`

This file is how the orchestrator knows you finished. Write it as your final action."

    log_info "Running $agent_name ($mode)..."

    local start_time=$(date +%s)

    setsid env -u CLAUDECODE -u CLAUDE_CODE_ENTRYPOINT \
        claude --model "$MODEL_PRIMARY" \
        --permission-mode acceptEdits \
        --allowedTools "Bash(git:*),Edit,Write,Read,Glob,Grep" \
        --output-format text \
        -p "$context_files
$prompt" &

    local agent_pid=$!

    # Wait for completion
    local timeout="$AGENT_TIMEOUT"
    local elapsed=0

    while [[ $elapsed -lt $timeout ]]; do
        if ! kill -0 "$agent_pid" 2>/dev/null; then
            break
        fi
        if [[ -f "$STATUS_DIR/result.json" ]]; then
            sleep 2
            break
        fi
        sleep 5
        elapsed=$((elapsed + 5))
    done

    # Kill if still running
    if kill -0 "$agent_pid" 2>/dev/null; then
        log_warning "Agent timed out after ${timeout}s, killing..."
        kill -TERM -"$agent_pid" 2>/dev/null || kill -TERM "$agent_pid" 2>/dev/null
        sleep 2
        kill -KILL -"$agent_pid" 2>/dev/null || true
    fi

    wait "$agent_pid" 2>/dev/null || true

    local duration=$(($(date +%s) - start_time))
    log_info "$agent_name finished in ${duration}s"

    # Log to agent-runs.log
    append_log "$LOGS_DIR/agent-runs.log" \
        "$(iso_timestamp)|$agent_name|$mode|${duration}s|$MODEL_PRIMARY|exit:$?"
}

check_result() {
    if [[ ! -f "$STATUS_DIR/result.json" ]]; then
        log_error "No result file - agent may have crashed"
        return 1
    fi

    local status=$(jq -r '.status // "unknown"' "$STATUS_DIR/result.json" 2>/dev/null)

    if [[ "$status" == "pass" ]]; then
        local summary=$(jq -r '.summary // "completed"' "$STATUS_DIR/result.json")
        log_success "$summary"
        return 0
    else
        local reason=$(jq -r '.reason // "unknown error"' "$STATUS_DIR/result.json")
        log_error "$reason"
        return 1
    fi
}

# ============================================================================
# COMMANDS
# ============================================================================

cmd_run() {
    local count="${1:-1}"
    local auto_commit=false

    # Parse run options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-commit) auto_commit=true; shift ;;
            *) [[ "$1" =~ ^[0-9]+$ ]] && count="$1"; shift ;;
        esac
    done

    load_config
    cd "$PROJECT_ROOT"

    log_header "aishore - Sprint Runner"
    echo "Project: $PROJECT_ROOT"
    echo "Sprints: $count"
    [[ "$auto_commit" == "true" ]] && echo "Auto-commit: enabled"
    echo ""

    local passed=0 failed=0

    for ((i=1; i<=count; i++)); do
        [[ $count -gt 1 ]] && log_subheader "Sprint $i/$count"

        # Pick item
        local item_json
        if ! item_json=$(pick_item); then
            log_warning "No ready items in backlog"
            break
        fi

        local item_source=$(get_item_source)
        [[ -z "$item_source" ]] && { log_error "Failed to determine item source"; break; }

        create_sprint "$item_json" "$item_source"

        # Run developer
        run_agent "developer" "implement"
        if ! check_result; then
            log_error "Implementation failed"
            ((failed++)) || true
            git checkout -- . 2>/dev/null || true
            git clean -fd 2>/dev/null || true
            reset_sprint
            continue
        fi

        # Run validator
        run_agent "validator" "validate"
        if ! check_result; then
            log_error "Validation failed"
            ((failed++)) || true
            git checkout -- . 2>/dev/null || true
            git clean -fd 2>/dev/null || true
            reset_sprint
            continue
        fi

        # Success
        if mark_complete "$ITEM_ID" "$item_source"; then
            log_success "Sprint complete: $ITEM_ID"
            ((passed++)) || true
        else
            log_error "Failed to mark $ITEM_ID complete"
            ((failed++)) || true
            continue
        fi

        # Handle commits
        if [[ "$auto_commit" == "true" ]]; then
            git add -A && git diff --cached --quiet || \
                git commit -m "feat($ITEM_ID): implement sprint item

Co-Authored-By: Claude <noreply@anthropic.com>"
        elif [[ $count -eq 1 ]]; then
            echo ""
            git status --short
            read -p "Commit? [y/N] " c
            if [[ $c == [yY] ]]; then
                git add -A && git commit -m "feat($ITEM_ID): implement sprint item

Co-Authored-By: Claude <noreply@anthropic.com>"
            fi
        fi
    done

    log_header "Results: $passed passed, $failed failed"
    [[ $failed -gt 0 || $passed -eq 0 ]] && exit 1 || exit 0
}

cmd_groom() {
    local mode="bugs"  # Default: tech lead grooms bugs
    [[ "${1:-}" == "--backlog" ]] && mode="backlog"

    load_config
    cd "$PROJECT_ROOT"

    if [[ "$mode" == "backlog" ]]; then
        log_header "Product Owner: Backlog Grooming"
        local agent="product-owner"
        local agent_mode="groom"
        local context="@$PLAN_DIR/backlog.json @$PLAN_DIR/bugs.json"
        [[ -f "$CONTEXT_PRODUCT" ]] && context="@$CONTEXT_PRODUCT $context"
        [[ -f "$CONTEXT_PROJECT" ]] && context="$context @$CONTEXT_PROJECT"
    else
        log_header "Tech Lead: Bugs/Tech Debt Grooming"
        local agent="tech-lead"
        local agent_mode="groom"
        local context="@$PLAN_DIR/backlog.json @$PLAN_DIR/bugs.json"
        [[ -f "$CONTEXT_PROJECT" ]] && context="$context @$CONTEXT_PROJECT"
    fi

    # Show current state
    local ready_backlog=$(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$PLAN_DIR/backlog.json" 2>/dev/null || echo 0)
    local ready_bugs=$(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$PLAN_DIR/bugs.json" 2>/dev/null || echo 0)
    log_info "Current ready buffer: $((ready_backlog + ready_bugs)) items ($ready_backlog features, $ready_bugs bugs)"
    echo ""

    rm -f "$STATUS_DIR/result.json"

    local prompt=$(cat "$AGENTS_DIR/${agent}.md")
    prompt="$prompt

## Mode
$agent_mode

## Completion Contract
When finished, write to \`.aishore/data/status/result.json\`:
\`\`\`json
{\"status\": \"pass\", \"summary\": \"Groomed X items, Y now ready for sprint\"}
\`\`\`"

    log_info "Running $agent agent..."

    setsid env -u CLAUDECODE -u CLAUDE_CODE_ENTRYPOINT \
        claude --model "$MODEL_PRIMARY" \
        --permission-mode acceptEdits \
        --allowedTools "Bash(git:*),Edit,Write,Read,Glob,Grep" \
        --output-format text \
        -p "$context
$prompt" &

    local agent_pid=$!
    local timeout="$AGENT_TIMEOUT"
    local elapsed=0

    while [[ $elapsed -lt $timeout ]]; do
        ! kill -0 "$agent_pid" 2>/dev/null && break
        [[ -f "$STATUS_DIR/result.json" ]] && { sleep 2; break; }
        sleep 5
        elapsed=$((elapsed + 5))
    done

    kill -0 "$agent_pid" 2>/dev/null && {
        kill -TERM -"$agent_pid" 2>/dev/null || kill -TERM "$agent_pid" 2>/dev/null
        sleep 2
        kill -KILL -"$agent_pid" 2>/dev/null || true
    }

    wait "$agent_pid" 2>/dev/null || true
    check_result
}

cmd_review() {
    local update_docs=false
    local since=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --update-docs) update_docs=true; shift ;;
            --since) since="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    load_config
    cd "$PROJECT_ROOT"

    log_header "Architecture Review"
    echo "Mode: $([[ "$update_docs" == "true" ]] && echo "Update docs" || echo "Read-only")"
    echo ""

    local context="@$PLAN_DIR/backlog.json @$PLAN_DIR/bugs.json @$ARCHIVE_DIR/sprints.jsonl"
    [[ -f "$CONTEXT_PROJECT" ]] && context="$context @$CONTEXT_PROJECT"

    local since_context=""
    if [[ -n "$since" ]]; then
        since_context="Review changes since commit: $since"
    fi

    local allowed_tools="Bash(git:*),Read,Glob,Grep"
    [[ "$update_docs" == "true" ]] && allowed_tools="Bash(git:*),Edit,Write,Read,Glob,Grep"

    local prompt=$(cat "$AGENTS_DIR/architect.md")
    prompt="$prompt

## Additional Context
$since_context
$([[ "$update_docs" == "true" ]] && echo "You may update project.md and add backlog items." || echo "Read-only review. Do not modify files.")

CRITICAL: End with: <<SIGNAL:ARCHITECT_REVIEW_COMPLETE>>"

    run_claude_agent "architect" "$MODEL_PRIMARY" "$allowed_tools" "$prompt" "$context"

    if check_signal "ARCHITECT_REVIEW_COMPLETE"; then
        log_success "Architecture review complete"
    else
        log_warning "Review may be incomplete"
    fi
}

cmd_metrics() {
    local json_output=false
    [[ "${1:-}" == "--json" ]] && json_output=true

    load_config

    local sprints_file="$ARCHIVE_DIR/sprints.jsonl"
    local backlog_file="$PLAN_DIR/backlog.json"
    local bugs_file="$PLAN_DIR/bugs.json"

    if [[ "$json_output" == "true" ]]; then
        local completed=$(wc -l < "$sprints_file" 2>/dev/null | tr -d ' ' || echo 0)
        local backlog_total=$(jq '.items | length' "$backlog_file" 2>/dev/null || echo 0)
        local bugs_total=$(jq '.items | length' "$bugs_file" 2>/dev/null || echo 0)
        local ready_backlog=$(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$backlog_file" 2>/dev/null || echo 0)
        local ready_bugs=$(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$bugs_file" 2>/dev/null || echo 0)

        cat <<EOF
{
  "timestamp": "$(date -Iseconds)",
  "sprints": {"completed": $completed},
  "backlog": {"total": $backlog_total, "ready": $ready_backlog},
  "bugs": {"total": $bugs_total, "ready": $ready_bugs}
}
EOF
    else
        log_header "aishore Metrics"
        echo ""
        echo "Completed Sprints: $(wc -l < "$sprints_file" 2>/dev/null | tr -d ' ' || echo 0)"
        echo ""
        echo "Backlog:"
        echo "  Total items: $(jq '.items | length' "$backlog_file" 2>/dev/null || echo 0)"
        echo "  Ready for sprint: $(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$backlog_file" 2>/dev/null || echo 0)"
        echo ""
        echo "Bugs/Tech Debt:"
        echo "  Total items: $(jq '.items | length' "$bugs_file" 2>/dev/null || echo 0)"
        echo "  Ready for sprint: $(jq '[.items[] | select(.readyForSprint == true and .passes != true)] | length' "$bugs_file" 2>/dev/null || echo 0)"
    fi
}

cmd_init() {
    log_header "Initializing aishore"

    # Check if already initialized
    if [[ -f "$CONFIG_FILE" ]]; then
        log_warning "aishore already initialized (config.yaml exists)"
        read -p "Reinitialize? [y/N] " c
        [[ $c != [yY] ]] && exit 0
    fi

    # Create config from template
    cat > "$CONFIG_FILE" << 'EOF'
# aishore configuration
# Edit this file to customize for your project

project:
  name: "My Project"

validation:
  # Command to run for validation (tests, linting, type checking)
  # Examples:
  #   Node.js: "npm run type-check && npm run lint && npm test"
  #   Python:  "pytest && mypy . && ruff check ."
  #   Go:      "go test ./... && go vet ./..."
  #   Rust:    "cargo test && cargo clippy"
  command: "echo 'Configure validation command in .aishore/config.yaml'"
  timeout: 120

models:
  # Primary model for developer, architect, tech-lead
  primary: "claude-opus-4-5-20251101"
  # Fast model for validator
  fast: "claude-sonnet-4-20250514"

agent:
  # Timeout for agent execution (seconds)
  timeout: 600

context:
  # Path to project conventions doc (relative to .aishore/ or absolute)
  project: "context/project.md"
  # Path to product vision doc (optional)
  product: ""
EOF

    # Create context placeholder
    cat > "$CONTEXT_DIR/project.md" << 'EOF'
# Project Context

Add your project conventions and architecture documentation here.

This file is read by all aishore agents to understand:
- Code style and patterns
- Project structure
- Testing conventions
- API patterns

You can also symlink to an existing file:
  ln -sf ../CLAUDE.md .aishore/context/project.md
EOF

    # Create .gitkeep files
    touch "$DATA_DIR/archive/.gitkeep"
    touch "$DATA_DIR/logs/.gitkeep"
    touch "$DATA_DIR/status/.gitkeep"
    touch "$PLAN_DIR/archive/.gitkeep"

    # Update .gitignore
    local gitignore="$PROJECT_ROOT/.gitignore"
    if [[ -f "$gitignore" ]]; then
        if ! grep -q ".aishore/data/logs/" "$gitignore" 2>/dev/null; then
            echo "" >> "$gitignore"
            echo "# aishore runtime files" >> "$gitignore"
            echo ".aishore/data/logs/" >> "$gitignore"
            echo ".aishore/data/status/result.json" >> "$gitignore"
        fi
    else
        cat > "$gitignore" << 'EOF'
# aishore runtime files
.aishore/data/logs/
.aishore/data/status/result.json
EOF
    fi

    log_success "aishore initialized!"
    echo ""
    echo "Next steps:"
    echo "  1. Edit .aishore/config.yaml - set your validation command"
    echo "  2. Edit .aishore/context/project.md - add project conventions"
    echo "     Or symlink: ln -sf ../CLAUDE.md .aishore/context/project.md"
    echo "  3. Add features to .aishore/plan/backlog.json"
    echo "  4. Run: .aishore/aishore groom"
    echo "  5. Run: .aishore/aishore run"
}

cmd_version() {
    echo "aishore version $AISHORE_VERSION"
}

cmd_help() {
    cat << EOF
aishore - AI Sprint Runner (v$AISHORE_VERSION)

Usage: .aishore/aishore <command> [options]

Commands:
  run [count]       Run sprints (default: 1)
    --auto-commit   Automatically commit after each sprint

  groom             Groom bugs/tech debt (Tech Lead mode)
    --backlog       Groom features instead (Product Owner mode)

  review            Architecture review (read-only)
    --update-docs   Allow updates to project docs
    --since <hash>  Review since specific commit

  metrics           Show sprint metrics
    --json          Output as JSON

  init              Initialize aishore in current project

  version           Show version
  help              Show this help

Examples:
  .aishore/aishore run              # Run 1 sprint
  .aishore/aishore run 5            # Run 5 sprints
  .aishore/aishore run --auto-commit 3
  .aishore/aishore groom            # Groom bugs (tech lead)
  .aishore/aishore groom --backlog  # Groom features (product owner)
  .aishore/aishore review
  .aishore/aishore metrics --json

Configuration:
  .aishore/config.yaml          All settings (validation, models, timeouts)
  .aishore/context/project.md   Project conventions (read by agents)
  .aishore/plan/backlog.json    Feature backlog
  .aishore/plan/bugs.json       Tech debt backlog
EOF
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    # Ensure directories exist
    mkdir -p "$STATUS_DIR" "$LOGS_DIR" "$ARCHIVE_DIR" "$PLAN_DIR/archive"

    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        run)     cmd_run "$@" ;;
        groom)   cmd_groom "$@" ;;
        review)  cmd_review "$@" ;;
        metrics) cmd_metrics "$@" ;;
        init)    cmd_init "$@" ;;
        version|-v|--version) cmd_version ;;
        help|-h|--help) cmd_help ;;
        *)
            log_error "Unknown command: $cmd"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
